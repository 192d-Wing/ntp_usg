# Version 3.3.0 - Hardware Integration Plan

**Target Release**: Q3 2026
**Status**: Planning Phase
**Current Version**: 3.2.0

## Overview

Version 3.3.0 focuses on hardware integration for high-precision time synchronization, enabling Stratum 1 operation with reference clocks.

## Goals

1. **GPS Receiver Support** - NMEA protocol parsing for GPS time
2. **PPS Integration** - Pulse Per Second signal handling
3. **Hardware Timestamping** - NIC-level timestamp capture
4. **Reference Clock API** - Generic interface for time sources

## Target Use Cases

- **Stratum 1 NTP servers** - Direct GPS/atomic clock synchronization
- **High-precision timing** - Sub-millisecond accuracy requirements
- **Edge computing** - Local time sources without internet
- **Critical infrastructure** - Redundant time sources
- **Scientific applications** - Nanosecond-level precision

---

## Feature 1: GPS Receiver Support

### Goal
Parse NMEA sentences from GPS receivers to extract accurate time and position data.

### Implementation

#### New Module: `crates/ntp_usg-client/src/refclock/gps.rs`

```rust
pub struct GpsReceiver {
    port: Box<dyn SerialPort>,
    parser: NmeaParser,
    last_fix: Option<GpsFix>,
}

pub struct GpsFix {
    pub timestamp: Timestamp,
    pub quality: FixQuality,
    pub satellites: u8,
    pub hdop: f64,  // Horizontal dilution of precision
    pub altitude: f64,
}

pub enum FixQuality {
    NoFix,
    Gps,
    DGps,  // Differential GPS
    Pps,   // PPS fix
}

impl GpsReceiver {
    pub fn new(port_name: &str, baud_rate: u32) -> io::Result<Self>;
    pub fn read_sentence(&mut self) -> io::Result<NmeaSentence>;
    pub fn get_time(&self) -> Option<Timestamp>;
}
```

#### NMEA Sentences to Support

- **$GPRMC** - Recommended Minimum Specific GPS/Transit Data
- **$GPGGA** - Global Positioning System Fix Data
- **$GPZDA** - Date & Time (preferred for NTP)

#### Dependencies

- `serialport` - Cross-platform serial port access
- `nmea0183` or custom parser - NMEA sentence parsing

### Testing

- Unit tests with mock NMEA data
- Integration test with simulated GPS device
- Real hardware test with USB GPS receiver

### Documentation

- GPS receiver setup guide
- Supported GPS modules list
- Troubleshooting common issues

---

## Feature 2: PPS (Pulse Per Second) Integration

### Goal
Capture PPS signals for sub-microsecond time synchronization.

### Implementation

#### New Module: `crates/ntp_usg-client/src/refclock/pps.rs`

```rust
pub struct PpsDevice {
    fd: RawFd,  // Linux: /dev/pps0
    last_pulse: Option<PpsTime>,
}

pub struct PpsTime {
    pub assert_time: Timespec,   // Rising edge
    pub clear_time: Option<Timespec>,  // Falling edge
    pub sequence: u32,
}

impl PpsDevice {
    pub fn open(device: &str) -> io::Result<Self>;
    pub fn wait_for_pulse(&mut self, timeout: Duration) -> io::Result<PpsTime>;
    pub fn fetch(&mut self) -> io::Result<PpsTime>;
}
```

#### Platform Support

- **Linux**: `/dev/pps*` with kernel PPS API
- **macOS**: Limited support via serial DCD/CTS lines
- **Windows**: Via serial port control lines

#### Kernel PPS API (Linux)

```rust
use libc::{KERN_PPS_API, PPS_GETPARAMS, PPS_SETPARAMS};

// ioctl calls for PPS management
pub fn pps_ioctl_fetch(fd: RawFd) -> io::Result<pps_info>;
pub fn pps_ioctl_params(fd: RawFd, params: &pps_params) -> io::Result<()>;
```

### Calibration

- Measure offset between GPS NMEA time and PPS pulse
- Compensate for serial line delay
- Track drift over time

### Testing

- Simulated PPS via software timer
- Hardware testing with GPS+PPS device
- Accuracy validation against known reference

---

## Feature 3: Hardware Timestamping

### Goal
Use NIC hardware timestamps to reduce network jitter.

### Implementation

#### New Module: `crates/ntp_usg-client/src/hw_timestamp.rs`

```rust
pub struct HardwareTimestamper {
    socket: UdpSocket,
    interface: String,
}

impl HardwareTimestamper {
    pub fn new(interface: &str) -> io::Result<Self>;
    pub fn send_with_timestamp(&self, packet: &[u8], addr: SocketAddr)
        -> io::Result<Timespec>;
    pub fn recv_with_timestamp(&self, buf: &mut [u8])
        -> io::Result<(usize, SocketAddr, Timespec)>;
}
```

#### Platform Support

- **Linux**: `SO_TIMESTAMPING` socket option
- **FreeBSD**: Similar socket options
- **Windows**: Limited support

#### Requirements

- NIC with hardware timestamping support (Intel I210/I211, etc.)
- Kernel PTP support
- Root/CAP_NET_RAW privileges

### Testing

- Software fallback when hardware not available
- Accuracy comparison vs software timestamps
- Network jitter reduction measurements

---

## Feature 4: Reference Clock API

### Goal
Generic interface for integrating various time sources.

### Implementation

#### New Module: `crates/ntp_usg-client/src/refclock/mod.rs`

```rust
#[async_trait]
pub trait RefClock: Send + Sync {
    async fn read_time(&mut self) -> io::Result<RefClockSample>;
    fn stratum(&self) -> u8;
    fn reference_id(&self) -> [u8; 4];
    fn poll_interval(&self) -> Duration;
}

pub struct RefClockSample {
    pub timestamp: Timestamp,
    pub offset: f64,
    pub dispersion: f64,
    pub quality: u8,  // 0-100 quality score
}

// Built-in implementations
pub struct GpsRefClock { /* ... */ }
pub struct PpsRefClock { /* ... */ }
pub struct AtomicClockRefClock { /* ... */ }
pub struct LocalClockRefClock { /* ... */ }  // For testing
```

#### Integration with NtpClient

```rust
impl NtpClientBuilder {
    pub fn refclock(mut self, clock: Box<dyn RefClock>) -> Self;
    pub fn prefer_refclock(mut self, prefer: bool) -> Self;
}
```

### Clock Selection

- Combine reference clock with network peers
- Weight based on quality and dispersion
- Fallback to network if reference clock fails

### Testing

- Mock reference clock for testing
- Multi-source selection algorithm
- Failover scenarios

---

## Feature 5: Stratum 1 Server Mode

### Goal
Enable NTP server to advertise Stratum 1 when using reference clock.

### Implementation

```rust
impl NtpServerBuilder {
    pub fn stratum_1_refclock(
        mut self,
        clock: Box<dyn RefClock>,
        ref_id: [u8; 4]  // e.g., b"GPS\0"
    ) -> Self;
}
```

#### Reference IDs

- `GPS` - GPS receiver
- `PPS` - PPS signal
- `ATOM` - Atomic clock
- `GOOG` - Google time (for testing)
- `LOCL` - Local clock (testing only)

### Validation

- Ensure reference clock quality before advertising Stratum 1
- Monitor clock health
- Automatic demotion to Stratum 2+ if reference fails

---

## New Dependencies

| Crate | Purpose | Optional Feature |
|-------|---------|------------------|
| `serialport` | GPS/PPS serial communication | `gps` |
| `nmea0183` | NMEA sentence parsing | `gps` |
| `libc` | PPS kernel API (Linux) | `pps` |
| `async-trait` | Async RefClock trait | `refclock` |

## Feature Flags

```toml
[features]
refclock = ["async-trait"]
gps = ["refclock", "serialport", "nmea0183"]
pps = ["refclock", "libc"]  # Linux only
hardware-timestamp = ["libc"]  # Linux/FreeBSD
stratum1 = ["refclock"]
```

## Platform Matrix

| Feature | Linux | macOS | Windows | FreeBSD |
|---------|-------|-------|---------|---------|
| GPS | ✅ | ✅ | ✅ | ✅ |
| PPS | ✅ | ⚠️  | ⚠️  | ✅ |
| HW Timestamp | ✅ | ❌ | ❌ | ✅ |
| Stratum 1 | ✅ | ✅ | ✅ | ✅ |

✅ Full support | ⚠️ Limited support | ❌ Not supported

---

## Examples

### GPS + PPS Stratum 1 Server

```rust
use ntp_server::server::NtpServer;
use ntp_client::refclock::{GpsRefClock, PpsRefClock};

#[tokio::main]
async fn main() -> io::Result<()> {
    // Open GPS receiver
    let gps = GpsRefClock::new("/dev/ttyUSB0", 9600)?;

    // Open PPS device
    let pps = PpsRefClock::new("/dev/pps0")?;

    // Configure server with both sources
    let server = NtpServer::builder()
        .listen("0.0.0.0:123")
        .refclock(Box::new(gps))
        .refclock(Box::new(pps))
        .stratum_1_reference(*b"GPS\0")
        .build()
        .await?;

    println!("Stratum 1 NTP server running");
    server.run().await
}
```

### Client with Local GPS

```rust
use ntp_client::client::NtpClient;
use ntp_client::refclock::GpsRefClock;

#[tokio::main]
async fn main() -> io::Result<()> {
    let gps = GpsRefClock::new("/dev/ttyUSB0", 9600)?;

    let (client, mut state_rx) = NtpClient::builder()
        .refclock(Box::new(gps))
        .prefer_refclock(true)  // Prefer GPS over network
        .server("time.nist.gov:123")  // Fallback
        .build()
        .await?;

    tokio::spawn(client.run());

    while state_rx.changed().await.is_ok() {
        let state = state_rx.borrow();
        println!("Time source: {} | Offset: {:.6}s",
                 state.source, state.offset);
    }

    Ok(())
}
```

---

## Testing Strategy

### Unit Tests
- NMEA parser with various sentence formats
- PPS pulse timing calculations
- RefClock trait implementations

### Integration Tests
- GPS receiver with mock serial data
- Simulated PPS pulses
- Multi-source clock selection

### Hardware Tests (Manual)
- Real GPS+PPS module (u-blox NEO-M8T, etc.)
- Network card with hardware timestamping
- Accuracy validation against known reference

### Performance Tests
- PPS pulse capture latency
- Hardware timestamp overhead
- Clock selection algorithm performance

---

## Documentation

### User Guides
- GPS receiver setup and configuration
- PPS device setup on Linux
- Hardware timestamping requirements
- Stratum 1 server deployment

### API Documentation
- RefClock trait and implementations
- GPS/PPS module documentation
- Hardware timestamp API

### Examples
- Basic GPS reader
- PPS signal monitoring
- Combined GPS+PPS Stratum 1 server
- Client with local reference clock

---

## Migration Path

### From v3.2.0

No breaking changes expected. New features are additive with optional feature flags.

```diff
 [dependencies]
-ntp_usg-client = { version = "3.2", features = ["tokio"] }
+ntp_usg-client = { version = "3.3", features = ["tokio", "gps", "pps"] }
```

---

## Success Criteria

- [ ] GPS receiver support with NMEA parsing
- [ ] PPS integration on Linux
- [ ] RefClock trait and API
- [ ] Stratum 1 server mode
- [ ] Hardware timestamping (Linux)
- [ ] Comprehensive documentation
- [ ] Working examples
- [ ] All tests pass
- [ ] Zero clippy warnings
- [ ] Zero security advisories

---

## Timeline

| Phase | Duration | Deliverables |
|-------|----------|--------------|
| Design & Planning | 2 weeks | This document, API design |
| GPS Implementation | 2 weeks | GPS module, NMEA parser |
| PPS Implementation | 2 weeks | PPS device interface |
| RefClock API | 1 week | Trait and integration |
| HW Timestamp | 2 weeks | Socket options, testing |
| Testing | 2 weeks | Integration, hardware tests |
| Documentation | 1 week | Guides, examples, API docs |
| **Total** | **12 weeks** | **Q3 2026** |

---

## Risks & Mitigation

| Risk | Mitigation |
|------|------------|
| GPS module availability | Support multiple popular modules |
| PPS kernel support | Provide software fallback |
| Hardware timestamp support | Feature-gate, graceful degradation |
| Testing without hardware | Comprehensive mock testing |
| Platform differences | Clear platform support matrix |

---

## Future Enhancements (v3.4.0+)

- DCF77 radio receiver support
- WWVB radio receiver support
- Rubidium atomic clock support
- IEEE 1588 PTP integration
- White Rabbit protocol
- Multi-source weighted combining

---

**Status**: ✅ Plan complete, ready for implementation

**Next Step**: Begin GPS receiver implementation
