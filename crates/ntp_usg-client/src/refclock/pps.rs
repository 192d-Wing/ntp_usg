// PPS (Pulse Per Second) reference clock implementation
//
// Provides nanosecond-level precision timing via Linux kernel PPS subsystem.
// PPS signals are typically generated by GPS receivers or atomic clocks.
//
// Requires Linux kernel with CONFIG_PPS enabled.

use super::{RefClock, RefClockSample};
use crate::unix_time;
use async_trait::async_trait;
use log::{debug, warn};
use std::fs::File;
use std::io::{self, Read};
use std::os::unix::io::AsRawFd;
use std::path::PathBuf;
use std::time::Duration;
use tokio::task;
use tokio::time::sleep;

// Linux PPS API constants (from <linux/pps.h>)
const PPS_GETPARAMS: u64 = 0x800470a1;
const PPS_SETPARAMS: u64 = 0x400470a2;
const PPS_GETCAP: u64 = 0x800470a3;
const PPS_FETCH: u64 = 0xc00470a4;

const PPS_CAPTUREASSERT: u32 = 0x01;
const PPS_CAPTURECLEAR: u32 = 0x02;
const PPS_CAPTUREBOTH: u32 = 0x03;

/// PPS timestamp from kernel
#[repr(C)]
#[derive(Debug, Clone, Copy)]
struct PpsTimespec {
    sec: i64,
    nsec: i64,
}

/// PPS fetch data structure
#[repr(C)]
#[derive(Debug, Clone, Copy)]
struct PpsFetchData {
    info: PpsInfo,
    timeout: PpsTimespec,
}

/// PPS information structure
#[repr(C)]
#[derive(Debug, Clone, Copy)]
struct PpsInfo {
    assert_sequence: u32,
    clear_sequence: u32,
    assert_tu: PpsTimespec,
    clear_tu: PpsTimespec,
    current_mode: u32,
}

/// PPS capture mode configuration
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum PpsCaptureMode {
    /// Capture on rising edge (assert)
    Assert,
    /// Capture on falling edge (clear)
    Clear,
    /// Capture both edges
    Both,
}

impl PpsCaptureMode {
    fn to_kernel_mode(self) -> u32 {
        match self {
            PpsCaptureMode::Assert => PPS_CAPTUREASSERT,
            PpsCaptureMode::Clear => PPS_CAPTURECLEAR,
            PpsCaptureMode::Both => PPS_CAPTUREBOTH,
        }
    }
}

/// PPS device configuration
#[derive(Clone, Debug)]
pub struct PpsConfig {
    /// PPS device path (e.g., "/dev/pps0")
    pub device: PathBuf,

    /// Capture mode (assert, clear, or both)
    pub capture_mode: PpsCaptureMode,

    /// Reference ID to report (e.g., b"PPS\0")
    pub reference_id: [u8; 4],

    /// Maximum time to wait for PPS pulse (seconds)
    pub timeout: Duration,

    /// Expected dispersion (uncertainty) in seconds
    pub dispersion: f64,
}

impl Default for PpsConfig {
    fn default() -> Self {
        Self {
            device: PathBuf::from("/dev/pps0"),
            capture_mode: PpsCaptureMode::Assert,
            reference_id: *b"PPS\0",
            timeout: Duration::from_secs(2),
            dispersion: 0.000001, // 1 microsecond
        }
    }
}

/// PPS reference clock
///
/// Provides nanosecond-precision time synchronization via PPS signals from
/// GPS receivers or atomic clocks. Requires Linux kernel PPS support.
pub struct PpsReceiver {
    config: PpsConfig,
    device: File,
    last_sequence: u32,
    capabilities: u32,
}

impl PpsReceiver {
    /// Create a new PPS receiver reference clock
    ///
    /// Opens the specified PPS device and configures capture mode.
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - PPS device cannot be opened
    /// - Device does not support PPS API
    /// - Requested capture mode not supported
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use ntp_client::refclock::pps::{PpsConfig, PpsReceiver, PpsCaptureMode};
    /// use std::path::PathBuf;
    ///
    /// # fn example() -> std::io::Result<()> {
    /// let config = PpsConfig {
    ///     device: PathBuf::from("/dev/pps0"),
    ///     capture_mode: PpsCaptureMode::Assert,
    ///     ..Default::default()
    /// };
    ///
    /// let pps = PpsReceiver::new(config)?;
    /// # Ok(())
    /// # }
    /// ```
    pub fn new(config: PpsConfig) -> io::Result<Self> {
        // Open PPS device
        let device = File::open(&config.device).map_err(|e| {
            io::Error::new(
                io::ErrorKind::Other,
                format!("Failed to open PPS device: {}", e),
            )
        })?;

        // Get PPS capabilities
        let capabilities = unsafe {
            let mut caps: u32 = 0;
            let ret = libc::ioctl(device.as_raw_fd(), PPS_GETCAP, &mut caps as *mut u32);
            if ret != 0 {
                return Err(io::Error::new(
                    io::ErrorKind::Other,
                    "Device does not support PPS API",
                ));
            }
            caps
        };

        debug!("PPS capabilities: 0x{:08x}", capabilities);

        // Verify requested capture mode is supported
        let requested_mode = config.capture_mode.to_kernel_mode();
        if (capabilities & requested_mode) != requested_mode {
            return Err(io::Error::new(
                io::ErrorKind::Other,
                format!(
                    "PPS device does not support requested capture mode: {:?}",
                    config.capture_mode
                ),
            ));
        }

        Ok(Self {
            config,
            device,
            last_sequence: 0,
            capabilities,
        })
    }

    /// Get PPS device capabilities
    pub fn capabilities(&self) -> u32 {
        self.capabilities
    }

    /// Fetch a PPS event from the kernel
    fn fetch_pps_event(&mut self, timeout_secs: u64) -> io::Result<PpsTimespec> {
        let mut fetch_data = PpsFetchData {
            info: PpsInfo {
                assert_sequence: 0,
                clear_sequence: 0,
                assert_tu: PpsTimespec { sec: 0, nsec: 0 },
                clear_tu: PpsTimespec { sec: 0, nsec: 0 },
                current_mode: 0,
            },
            timeout: PpsTimespec {
                sec: timeout_secs as i64,
                nsec: 0,
            },
        };

        unsafe {
            let ret = libc::ioctl(
                self.device.as_raw_fd(),
                PPS_FETCH,
                &mut fetch_data as *mut PpsFetchData,
            );
            if ret != 0 {
                return Err(io::Error::last_os_error());
            }
        }

        // Select timestamp based on capture mode
        let (timestamp, sequence) = match self.config.capture_mode {
            PpsCaptureMode::Assert => {
                (fetch_data.info.assert_tu, fetch_data.info.assert_sequence)
            }
            PpsCaptureMode::Clear => {
                (fetch_data.info.clear_tu, fetch_data.info.clear_sequence)
            }
            PpsCaptureMode::Both => {
                // Use whichever edge occurred more recently
                if fetch_data.info.assert_sequence > fetch_data.info.clear_sequence {
                    (fetch_data.info.assert_tu, fetch_data.info.assert_sequence)
                } else {
                    (fetch_data.info.clear_tu, fetch_data.info.clear_sequence)
                }
            }
        };

        // Check for new event
        if sequence <= self.last_sequence {
            return Err(io::Error::new(
                io::ErrorKind::TimedOut,
                "No new PPS event received",
            ));
        }

        self.last_sequence = sequence;
        debug!(
            "PPS event #{}: {}.{:09}",
            sequence, timestamp.sec, timestamp.nsec
        );

        Ok(timestamp)
    }
}

#[async_trait]
impl RefClock for PpsReceiver {
    async fn read_sample(&mut self) -> io::Result<RefClockSample> {
        // Fetch PPS event in blocking task (kernel ioctl blocks)
        let timeout_secs = self.config.timeout.as_secs();
        let config = self.config.clone();

        // Clone file descriptor for blocking operation
        let fd = self.device.as_raw_fd();
        let last_seq = self.last_sequence;

        let result = task::spawn_blocking(move || -> io::Result<(PpsTimespec, u32)> {
            let mut fetch_data = PpsFetchData {
                info: PpsInfo {
                    assert_sequence: 0,
                    clear_sequence: 0,
                    assert_tu: PpsTimespec { sec: 0, nsec: 0 },
                    clear_tu: PpsTimespec { sec: 0, nsec: 0 },
                    current_mode: 0,
                },
                timeout: PpsTimespec {
                    sec: timeout_secs as i64,
                    nsec: 0,
                },
            };

            unsafe {
                let ret = libc::ioctl(fd, PPS_FETCH, &mut fetch_data as *mut PpsFetchData);
                if ret != 0 {
                    return Err(io::Error::last_os_error());
                }
            }

            let (timestamp, sequence) = match config.capture_mode {
                PpsCaptureMode::Assert => {
                    (fetch_data.info.assert_tu, fetch_data.info.assert_sequence)
                }
                PpsCaptureMode::Clear => {
                    (fetch_data.info.clear_tu, fetch_data.info.clear_sequence)
                }
                PpsCaptureMode::Both => {
                    if fetch_data.info.assert_sequence > fetch_data.info.clear_sequence {
                        (fetch_data.info.assert_tu, fetch_data.info.assert_sequence)
                    } else {
                        (fetch_data.info.clear_tu, fetch_data.info.clear_sequence)
                    }
                }
            };

            if sequence <= last_seq {
                return Err(io::Error::new(
                    io::ErrorKind::TimedOut,
                    "No new PPS event received",
                ));
            }

            Ok((timestamp, sequence))
        })
        .await
        .map_err(|e| io::Error::new(io::ErrorKind::Other, format!("Task join error: {}", e)))?;

        let (pps_time, sequence) = result?;
        self.last_sequence = sequence;

        // Convert PPS timestamp to Instant
        let pps_instant = unix_time::Instant::new(pps_time.sec as i64, pps_time.nsec as u32);

        // Get current system time
        let now = unix_time::Instant::now();

        // Calculate offset: PPS time - system time
        let pps_secs = pps_time.sec as f64 + (pps_time.nsec as f64 / 1e9);
        let now_secs = now.secs() as f64 + (now.subsec_nanos() as f64 / 1e9);
        let offset = pps_secs - now_secs;

        debug!(
            "PPS offset: {:.9}s (PPS: {:.9}, System: {:.9})",
            offset, pps_secs, now_secs
        );

        Ok(RefClockSample {
            timestamp: pps_instant,
            offset,
            dispersion: self.config.dispersion,
            quality: 255, // Maximum quality - PPS is extremely precise
        })
    }

    fn stratum(&self) -> u8 {
        // PPS is a Stratum 0 source, so we report Stratum 1
        1
    }

    fn reference_id(&self) -> [u8; 4] {
        self.config.reference_id
    }

    fn poll_interval(&self) -> Duration {
        Duration::from_secs(1) // Poll every second
    }

    fn is_healthy(&self) -> bool {
        // Could check for recent successful reads, but for now assume healthy if device is open
        true
    }

    fn description(&self) -> &str {
        "PPS (Pulse Per Second)"
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pps_config_default() {
        let config = PpsConfig::default();
        assert_eq!(config.device, PathBuf::from("/dev/pps0"));
        assert_eq!(config.capture_mode, PpsCaptureMode::Assert);
        assert_eq!(config.reference_id, *b"PPS\0");
        assert_eq!(config.timeout, Duration::from_secs(2));
        assert_eq!(config.dispersion, 0.000001);
    }

    #[test]
    fn test_pps_capture_mode_conversion() {
        assert_eq!(
            PpsCaptureMode::Assert.to_kernel_mode(),
            PPS_CAPTUREASSERT
        );
        assert_eq!(PpsCaptureMode::Clear.to_kernel_mode(), PPS_CAPTURECLEAR);
        assert_eq!(PpsCaptureMode::Both.to_kernel_mode(), PPS_CAPTUREBOTH);
    }

    // Note: Actual PPS tests require hardware (GPS with PPS output) and are omitted.
    // Mock PPS device tests could be added with a kernel module or simulator.
}
